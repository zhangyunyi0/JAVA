本文转载自GitHub中Snailclimb的JavaGuide，仅用于自学使用，来源：[https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.md#2-java-%E8%AF%AD%E8%A8%80%E6%9C%89%E5%93%AA%E4%BA%9B%E7%89%B9%E7%82%B9](https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.md#2-java-%E8%AF%AD%E8%A8%80%E6%9C%89%E5%93%AA%E4%BA%9B%E7%89%B9%E7%82%B9)
##1.面向对象和面向过程的区别

- **面向过程：面向过程性能比面向对象高。**因为类调用时需要实例化，开销比较大，比较消耗资源，所以当性能是最重要的考量因素的时候，比如单片机、嵌入式开发、Linux/Unix等一般采用面向过程开发。但是，**面向过程没有面向对象易维护、易复用、易扩展。**
- **面向对象：面向对象易维护、易复用、易扩展。**因为面向对象有封装、继承、多态性的特性，所以可以设计出低耦合的系统，使系统更加灵活、更加易于维护。但是，**面向对象性能比面向过程低**。

>这个并不是根本原因，面向过程也需要分配内存，计算内存偏移量，Java性能差的主要原因并不是因为它是面向对象语言，而是Java是半编译语言，最终的执行代码并不是可以直接被CPU执行的二进制机械码。

>而面向过程语言大多都是直接编译成机械码在电脑上执行，并且其他一些面向过程的脚本语言性能也不一定比Java好。

##2.Java语言有哪些特点？

1. 简单易学；
2. 面向对象（封装，继承，多态）；
3. 平台无关性（Java虚拟机实现平台无关性）；
4. 可靠性；
5. 安全性；
6. 支持多线程（C++语言没有内置的多线程机制，因此必须调用操作系统的多线程功能来进行多线程程序设计，而Java语言却提供了多线程支持）；
7. 支持网络编程并且很方便（Java语言诞生本身就是为简化网络编程设计的，因此Java语言不仅支持网络编程而且很方便）；
8. 编译与解释并存；

##3.关于JVM JDK和JRE最详细通俗的解答
###JVM
Java虚拟机（JVM）是运行Java字节码的虚拟机。JVM有针对不同系统的特定实现（Windows,Linux,macOS），目的是使用相同的字节码，它们都会给出相同的结果。

**什么是字节码？采用字节码的好处是什么？**

>在Java中，KVM可以理解的代码就叫做`字节码`（即扩展名为`.class`的文件），它不面向任何特定的处理器，只面向虚拟机。Java语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以Java程序运行时比较高效，而且，由于字节码并不针对一种特定的机器，因此，Java程序无须重新编译便可在多种不同的操作系统的计算机上运行。

**Java程序从源代码到运行一般有下面3步：

`.java文件（源代码）`经过JDK中的javac编译得到 `.class文件（JVM可理解的Java字节）`再经过JVM解释得到 `机器可执行的二进制机器码`

我们需要格外注意的是.class->机器码 这一步。在这一步JVM类加载器首先加载字节码文件，然后通过解释器逐行解释执行，这种方式的执行速度会相对比较慢。而且，有些方法和代码块是经常需要被调用的（也就是所谓的热点代码），所以后面引进了JIT编译器，而JIT属于运行时编译。当JIT编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。而我们知道，机器码的运行效率肯定是高于Java解释器的。这也解释了我们为什么经常会说Java是编译与解释共存的语言。

>HotSpot采用了惰性评估（Lazy Evaluation）的做法，根据二八定律，消耗大部分系统资源的只有那一小部分的代码（热点代码），而这也就是JIT所需要编译的部分。JVM会根据代码每次被执行的情况收集信息并相应地做出一些优化，因此执行的次数越多，它的速度就越快。JDK 9引入了一种新的编译模式AOT（Ahead of Time Conmpilation），它是直接将字节码编译成机器码，这样就避免了JIT预热等各方面的开销。JDK支持分层编译和AOT协作使用。但是，AOT编译器的编译质量是肯定比不上JIT编译器的。

**总结：**

Java虚拟机（JVM）是运行Java字节码的虚拟机。JVM有针对不同系统的特定实现（Windows,Linux,macOS），目的是使用相同的字节码，它们都会给出相同的结果。字节码和不同系统的JVM实现是Java语言“一次编译，随处可以运行”的关键所在。

###JDK和JRE

JDK是Java Development Kit，它是功能齐全的Java SDK。它拥有JRE所拥有的一切，还有编译器（javac）和工具（如javadoc和jdb）。它能够创建和编译程序
JRE是Java运行时环境。它是运行已编译Java程序所需的所有内容的集合，包括Java虚拟机（JVM），Java类库，java命令和其他的一些基础构件。但是，它不能用于创建新程序。
如果你只是为了运行一下Java程序的话，那么你只需要安装JRE就可以了。如果你需要进行一些Java编程方面的工作，那么你就需要安装JDK了。但是，这不是绝对的。有时，即使您不打算在计算机上进行任何Java开发，仍然需要安装JDK。例如，如果要使用JSP部署WEB应用程序，那么从技术上讲，您只是在应用程序服务器中运行Java程序。那你为什么需要JDK呢？因为应用程序服务器会将JSP转换为Java servlet，并且需要使用JDK来编译servlet。

##4.Oracle JDK和OpenJDK的对比

可能在看这个问题之前很多人和我一样并没有接触和使用过OpenJDK。那么Oracle和OpenJDK之间是否存在重大差异？下面我通过收集到的一些资料，为你解答这个被很多人忽视的问题。

对于Java 7，没什么关键的地方。OpenJDK项目主要基于Sun捐赠的HotSpot源代码。此外，OpenJDK被选为Java 7的参考实现，由Oracle工程师维护。关于JVM，JDK和OpenJDK之间的区别，Oracle博客帖子在2012年有一个更详细的答案：

>问：OpenJDK存储库中的源代码与用于构建Oracle JDK的代码之间有什么区别？

>答：非常接近，我们的Oracle JDK版本构建过程基于OpenJDK 7构建，只添加了几个部分，例如部署代码，其中包括Oracle的Java插件和Java WebStart的实现，以及一些封闭的源代码组件，如图形光栅化器，一些开源的第三方组件，如Rhino，以及一些零碎的东西，如附加文档或第三方字体。展望未来，我们的目的是开源Oracle JDK的所有部分，除了我们考虑商业功能的部分。

**总结：**

1. Oracle JDK大概每6个月发一次主要版本，而OpenJDK版本大概每三个月发布一次。但这不是固定的，我觉得了解这个没啥用处；
2. OpenJDK是一个参考模型并且是完全开源的，而Oracle JDK是OpenJDK的一个实现，并不是完全开源的；
3. Oracle JDK比OpenJDK更稳定。OpenJDK和Oracle JDK的代码几乎相同，但Oracle JDK有更多的类和一些错误修复。因此，如果您想开发企业/商业软件，我建议您选择Oracle JDK,因为它经过了彻底的测试和稳定。某些情况下，有些人提到在使用OpenJDK可能会遇到许多应用程序崩溃的问题，但是，只需切换到Oracle JDK就可以解决问题；
4. 在响应性和JVM性能方面，Oracle JDK与OpenJDK相比提供了更好地性能；
5. Oracle JDK不会为即将发布的版本提供长期支持，用户每次都必须通过更新到最新版本来获得支持；
6. Oracle JDK根据二进制代码许可协议获得许可，而OpenJDK根据GPL v2许可获得许可。

##5.Java和C++的区别？
很多人没学过C++，但是面试官就是没事喜欢拿咱们Java和C++比呀！没办法！！！就算没学过C++，也要记下来！

- 都是面向对象的语言，都支持封装、继承和多态
- Java不提供指针来直接访问内存，程序内存更加安全
- Java的类是单继承的，C++支持多重继承；虽然Java的类不可以多继承，但是接口可以多继承。
- Java有自动内存管理机制，不需要程序员手动释放无用内存

##6.什么是Java程序的主类？应用程序和小程序的主类有何不同？

一个程序中可以有多个类，但只能有一个类是主类。在Java应用程序中，这个主类是指包含main（）方法的类。而在Java小程序中，这个主类是一个继承自系统类JApplet或Applet的子类。应用程序的主类不一定要求是public类，但小程序的主类要求必须是public类。主类是Java程序执行的入口点。

##7.Java应用程序与小程序之间有哪些差别？

简单说应用程序是从主线程启动（也就是`main（）`方法）。applet小程序没有`main（）`方法，主要是嵌在浏览器页面上运行（调用`init()`或者`run（）`来启动，嵌入浏览器这点跟flash的小游戏类似。

##8.字符型常量和字符串常量的区别？

1. 形式上：字符常量是单引号引起的一个字符；字符串常量是双引号引起的若干个字符
2. 含义上：字符常量相当于一个整形值（ASCII值），可以参加表达式运算；字符串常量代表一个地址值（该字符串在内存中存放位置）
3. 占内存大小：字符常量只占2个字节；字符串常量占若干个字节（至少一个字符结束标志）（**注意：char在Java中占两个字节**）

>Java要确定每种基本类型所占存储空间的大小。它们的大小并不像其他大多数语言那样随机器硬件架构的变化而变化。这种所占存储空间大小的不变性是Java程序比其他大多数语言编写的程序更具可移植性的原因之一。

    |基本类型| 大小 |  最小值  |    最大值     |包装器类型| 
    |boolean|  ——  |   ——    |      ——      |Boolean  |
    |char   |16-bit|Unicode 0|Unicode 2^16-1|Character|
    |byte   |8 bits|-128     |+127          |Byte     |
    |short  |16bits|-2^15    |+2^15-1       |Short    |
    |int    |32bits|-2^31    |+2^31-1       |Integer  |
    |long   |64bits|-2^63    |+2^63-1       |Long     |
    |float  |32bits|IEEE754  |IEEE754       |Float    |
    |double |64bits|IEEE754  |IEEE754       |Double   |
    |void   |  ——  |   ——    |      ——      |Void     |

##9.构造器Constructor是否可被override？

在讲继承的时候我们就知道父类的私有属性和构造方法并不能被继承，所以Constructor也就不能被override（重写），但是可以overload（重载），所以你可以看到一个类中有多个构造函数的情况。

##10.重载和重写的区别
 - **重载**：发生在同一个类中，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同，发生在编译时。
 - **重写**：发生在父子类中，方法名、参数列表必须相同，返回值范围小于等于父类，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类；如果父类方法访问修饰符为private则子类就不能重写该方法。

##11.Java面向对象编程三大特性：封装 继承 多态

###封装
封装把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法，如果属性不想被外界访问，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。

###继承
继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承我们能够非常方便地复用以前的代码。

**关于继承如下3点请记住：**

1. 子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问的，**只是拥有**。
2. 子类可以拥有自己的属性和方法，即子类可以对父类进行扩展。
3. 子类可以用自己的方式实现父类的方法。

###多态

所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。

在Java中有两种形式可以实现多态：继承（多个子类对同一方法的重写）和接口（实现接口并覆盖接口中同一方法）。

##12.String StringBuffer和StringBuilder的区别是什么？String为什么是不可变的？

###可变性
简单的来说：String类中使用final关键字修饰字符数组来保存字符串，`private final char value[]`，所以String对象是不可变的。而StringBuilder与StringBuffer都继承自AbstractStringBuilder类，在AbstractStringBuilder中也是使用字符数组保存字符串`char[]value`但是没有用final关键字修饰，所以这两种对象都是可变的。

StringBuilder与StringBuffer的构造方法都是调用父类构造方法也就是AbstractStringBuilder实现的，大家可以自行查阅源码。

AbstractStringBuilder.java

	abstract class AbstractStringBuilder implements Appendable, CharSequence {
    	char[] value;
    	int count;
    	AbstractStringBuilder() {
   		}
    	AbstractStringBuilder(int capacity) {
        	value = new char[capacity];
    	}

###线程安全性

String中的对象是不可变的，也就可以理解为常量，线程安全。AbstractStringBuilder是StringBuilder与StringBuffer的公共父类，定义了一些字符串的基本操作，如expandCapacity、append、insert、indexOf等公共方法。StringBuffer对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder并没有对方法进行加同步锁，所以是非线程安全的。

###性能

每次对String类型进行改变的时候，都会生成一个新的String对象，然后将指针指向新的String对象。StringBuffer每次都会对StringBuffer对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用StringBuilder相比使用StringBuffer仅能获得10%~15%左右的性能提升，但却要冒多线程不安全的风险。

###对于三者使用的总结：

1. 操作少量的数据：适用String
2. 单线程操作字符串缓冲区下操作大量数据：适用StringBuilder
3. 多线程操作字符串缓冲区下操作大量数据：适用StringBuffer

##13.自动装箱与拆箱
 - 装箱：将基本类型用它们对应的引用类型包装起来；
 - 拆箱：将包装类型转换为基本数据类型；

##14.在一个静态方法内调用一个非静态成员为什么是非法的？
由于静态方法可以不通过对象进行调用，因此在静态方法里，不能调用其他非静态变量，也不可以访问非静态变量成员 。

##15.在Java中定义一个不做事且没有参数的构造方法的作用
Java程序在执行子类的构造方法之前，如果没有用`super（）`来调用父类特定的构造方法，则会调用父类中“没有参数的构造方法”。因此，如果父类中只定义了有参数的构造方法，而在子类的构造方法中又没有用`super（）`来调用父类中特定的构造方法，则编译时将发生错误，因为Java程序在父类中找不到没有参数的构造方法可供执行。解决办法是在父类里加上一个不做事且没有参数的构造方法。

##16.import java 和javax有什么区别？
刚开始的时候JavaAPI所必需的包是java开头的包，javax当时只是扩展API包来使用。然而随着时间的推移，javax逐渐地扩展成为Java API的组成部分。但是，将扩展从javax包移动到java包确实太麻烦了，最终会破坏一堆现有的代码。因此,最终决定javax包将成为标准API的一部分。

所以，实际上java和javax没有区别。这都是一个名字。

##17.接口和抽象类的区别是什么？
1. 接口的方法默认是public，所有方法在接口中不能有实现（Java 8开始接口方法可以有默认实现），而抽象类可以有非抽象的方法。
2. 接口中除了static、final变量，不能有其他变量，而抽象类中则不一定。
3. 一个类可以实现多个接口，但只能实现一个抽象类。接口自己本身可以通过extends关键字扩展多个接口。
4. 接口方法默认修饰符是public，抽象方法可以有public、protected和default这些修饰符（抽象方法就是为了被重写所以不能使用private关键字修饰！）
5. 从设计层面来说，抽象是对类的抽象，是一种模板设计，而接口是对行为的抽象，是一种行为的规范。

备注：在JDK 8中，接口也可以定义静态方法，可以直接用接口名调用。如果同时实现两个接口，接口中定义了一样的默认方法，则必须重写，不然会报错。
