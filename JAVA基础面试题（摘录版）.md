本文转载自GitHub中Snailclimb的JavaGuide，仅用于自学使用，来源：[https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.md#2-java-%E8%AF%AD%E8%A8%80%E6%9C%89%E5%93%AA%E4%BA%9B%E7%89%B9%E7%82%B9](https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.md#2-java-%E8%AF%AD%E8%A8%80%E6%9C%89%E5%93%AA%E4%BA%9B%E7%89%B9%E7%82%B9)
##1.面向对象和面向过程的区别

- **面向过程：面向过程性能比面向对象高。**因为类调用时需要实例化，开销比较大，比较消耗资源，所以当性能是最重要的考量因素的时候，比如单片机、嵌入式开发、Linux/Unix等一般采用面向过程开发。但是，**面向过程没有面向对象易维护、易复用、易扩展。**
- **面向对象：面向对象易维护、易复用、易扩展。**因为面向对象有封装、继承、多态性的特性，所以可以设计出低耦合的系统，使系统更加灵活、更加易于维护。但是，**面向对象性能比面向过程低**。

>这个并不是根本原因，面向过程也需要分配内存，计算内存偏移量，Java性能差的主要原因并不是因为它是面向对象语言，而是Java是半编译语言，最终的执行代码并不是可以直接被CPU执行的二进制机械码。

>而面向过程语言大多都是直接编译成机械码在电脑上执行，并且其他一些面向过程的脚本语言性能也不一定比Java好。

##2.Java语言有哪些特点？

1. 简单易学；
2. 面向对象（封装，继承，多态）；
3. 平台无关性（Java虚拟机实现平台无关性）；
4. 可靠性；
5. 安全性；
6. 支持多线程（C++语言没有内置的多线程机制，因此必须调用操作系统的多线程功能来进行多线程程序设计，而Java语言却提供了多线程支持）；
7. 支持网络编程并且很方便（Java语言诞生本身就是为简化网络编程设计的，因此Java语言不仅支持网络编程而且很方便）；
8. 编译与解释并存；

##3.关于JVM JDK和JRE最详细通俗的解答
###JVM
Java虚拟机（JVM）是运行Java字节码的虚拟机。JVM有针对不同系统的特定实现（Windows,Linux,macOS），目的是使用相同的字节码，它们都会给出相同的结果。

**什么是字节码？采用字节码的好处是什么？**

>在Java中，KVM可以理解的代码就叫做`字节码`（即扩展名为`.class`的文件），它不面向任何特定的处理器，只面向虚拟机。Java语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以Java程序运行时比较高效，而且，由于字节码并不针对一种特定的机器，因此，Java程序无须重新编译便可在多种不同的操作系统的计算机上运行。

**Java程序从源代码到运行一般有下面3步：

`.java文件（源代码）`经过JDK中的javac编译得到 `.class文件（JVM可理解的Java字节）`再经过JVM解释得到 `机器可执行的二进制机器码`

我们需要格外注意的是.class->机器码 这一步。在这一步JVM类加载器首先加载字节码文件，然后通过解释器逐行解释执行，这种方式的执行速度会相对比较慢。而且，有些方法和代码块是经常需要被调用的（也就是所谓的热点代码），所以后面引进了JIT编译器，而JIT属于运行时编译。当JIT编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。而我们知道，机器码的运行效率肯定是高于Java解释器的。这也解释了我们为什么经常会说Java是编译与解释共存的语言。

>HotSpot采用了惰性评估（Lazy Evaluation）的做法，根据二八定律，消耗大部分系统资源的只有那一小部分的代码（热点代码），而这也就是JIT所需要编译的部分。JVM会根据代码每次被执行的情况收集信息并相应地做出一些优化，因此执行的次数越多，它的速度就越快。JDK 9引入了一种新的编译模式AOT（Ahead of Time Conmpilation），它是直接将字节码编译成机器码，这样就避免了JIT预热等各方面的开销。JDK支持分层编译和AOT协作使用。但是，AOT编译器的编译质量是肯定比不上JIT编译器的。

**总结：**

Java虚拟机（JVM）是运行Java字节码的虚拟机。JVM有针对不同系统的特定实现（Windows,Linux,macOS），目的是使用相同的字节码，它们都会给出相同的结果。字节码和不同系统的JVM实现是Java语言“一次编译，随处可以运行”的关键所在。

###JDK和JRE

JDK是Java Development Kit，它是功能齐全的Java SDK。它拥有JRE所拥有的一切，还有编译器（javac）和工具（如javadoc和jdb）。它能够创建和编译程序
JRE是Java运行时环境。它是运行已编译Java程序所需的所有内容的集合，包括Java虚拟机（JVM），Java类库，java命令和其他的一些基础构件。但是，它不能用于创建新程序。
如果你只是为了运行一下Java程序的话，那么你只需要安装JRE就可以了。如果你需要进行一些Java编程方面的工作，那么你就需要安装JDK了。但是，这不是绝对的。有时，即使您不打算在计算机上进行任何Java开发，仍然需要安装JDK。例如，如果要使用JSP部署WEB应用程序，那么从技术上讲，您只是在应用程序服务器中运行Java程序。那你为什么需要JDK呢？因为应用程序服务器会将JSP转换为Java servlet，并且需要使用JDK来编译servlet。

##4.Oracle JDK和OpenJDK的对比

可能在看这个问题之前很多人和我一样并没有接触和使用过OpenJDK。那么Oracle和OpenJDK之间是否存在重大差异？下面我通过收集到的一些资料，为你解答这个被很多人忽视的问题。

对于Java 7，没什么关键的地方。OpenJDK项目主要基于Sun捐赠的HotSpot源代码。此外，OpenJDK被选为Java 7的参考实现，由Oracle工程师维护。关于JVM，JDK和OpenJDK之间的区别，Oracle博客帖子在2012年有一个更详细的答案：

>问：OpenJDK存储库中的源代码与用于构建Oracle JDK的代码之间有什么区别？

>答：非常接近，我们的Oracle JDK版本构建过程基于OpenJDK 7构建，只添加了几个部分，例如部署代码，其中包括Oracle的Java插件和Java WebStart的实现，以及一些封闭的源代码组件，如图形光栅化器，一些开源的第三方组件，如Rhino，以及一些零碎的东西，如附加文档或第三方字体。展望未来，我们的目的是开源Oracle JDK的所有部分，除了我们考虑商业功能的部分。

**总结：**

1. Oracle JDK大概每6个月发一次主要版本，而OpenJDK版本大概每三个月发布一次。但这不是固定的，我觉得了解这个没啥用处；
2. OpenJDK是一个参考模型并且是完全开源的，而Oracle JDK是OpenJDK的一个实现，并不是完全开源的；
3. Oracle JDK比OpenJDK更稳定。OpenJDK和Oracle JDK的代码几乎相同，但Oracle JDK有更多的类和一些错误修复。因此，如果您想开发企业/商业软件，我建议您选择Oracle JDK,因为它经过了彻底的测试和稳定。某些情况下，有些人提到在使用OpenJDK可能会遇到许多应用程序崩溃的问题，但是，只需切换到Oracle JDK就可以解决问题；
4. 在响应性和JVM性能方面，Oracle JDK与OpenJDK相比提供了更好地性能；
5. Oracle JDK不会为即将发布的版本提供长期支持，用户每次都必须通过更新到最新版本来获得支持；
6. Oracle JDK根据二进制代码许可协议获得许可，而OpenJDK根据GPL v2许可获得许可。

##5.Java和C++的区别？
很多人没学过C++，但是面试官就是没事喜欢拿咱们Java和C++比呀！没办法！！！就算没学过C++，也要记下来！

- 都是面向对象的语言，都支持封装、继承和多态
- Java不提供指针来直接访问内存，程序内存更加安全
- Java的类是单继承的，C++支持多重继承；虽然Java的类不可以多继承，但是接口可以多继承。
- Java有自动内存管理机制，不需要程序员手动释放无用内存

##6.什么是Java程序的主类？应用程序和小程序的主类有何不同？

一个程序中可以有多个类，但只能有一个类是主类。在Java应用程序中，这个主类是指包含main（）方法的类。而在Java小程序中，这个主类是一个继承自系统类JApplet或Applet的子类。应用程序的主类不一定要求是public类，但小程序的主类要求必须是public类。主类是Java程序执行的入口点。

##7.Java应用程序与小程序之间有哪些差别？

简单说应用程序是从主线程启动（也就是`main（）`方法）。applet小程序没有`main（）`方法，主要是嵌在浏览器页面上运行（调用`init()`或者`run（）`来启动，嵌入浏览器这点跟flash的小游戏类似。

##8.字符型常量和字符串常量的区别？

1. 形式上：字符常量是单引号引起的一个字符；字符串常量是双引号引起的若干个字符
2. 含义上：字符常量相当于一个整形值（ASCII值），可以参加表达式运算；字符串常量代表一个地址值（该字符串在内存中存放位置）
3. 占内存大小：字符常量只占2个字节；字符串常量占若干个字节（至少一个字符结束标志）（**注意：char在Java中占两个字节**）

>Java要确定每种基本类型所占存储空间的大小。它们的大小并不像其他大多数语言那样随机器硬件架构的变化而变化。这种所占存储空间大小的不变性是Java程序比其他大多数语言编写的程序更具可移植性的原因之一。

    |基本类型| 大小 |  最小值  |    最大值     |包装器类型| 
    |boolean|  ——  |   ——    |      ——      |Boolean  |
    |char   |16-bit|Unicode 0|Unicode 2^16-1|Character|
    |byte   |8 bits|-128     |+127          |Byte     |
    |short  |16bits|-2^15    |+2^15-1       |Short    |
    |int    |32bits|-2^31    |+2^31-1       |Integer  |
    |long   |64bits|-2^63    |+2^63-1       |Long     |
    |float  |32bits|IEEE754  |IEEE754       |Float    |
    |double |64bits|IEEE754  |IEEE754       |Double   |
    |void   |  ——  |   ——    |      ——      |Void     |

##9.构造器Constructor是否可被override？

在讲继承的时候我们就知道父类的私有属性和构造方法并不能被继承，所以Constructor也就不能被override（重写），但是可以overload（重载），所以你可以看到一个类中有多个构造函数的情况。

##10.重载和重写的区别
 - **重载**：发生在同一个类中，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同，发生在编译时。
 - **重写**：发生在父子类中，方法名、参数列表必须相同，返回值范围小于等于父类，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类；如果父类方法访问修饰符为private则子类就不能重写该方法。

##11.Java面向对象编程三大特性：封装 继承 多态

###封装
封装把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法，如果属性不想被外界访问，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。

###继承
继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承我们能够非常方便地复用以前的代码。

**关于继承如下3点请记住：**

1. 子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问的，**只是拥有**。
2. 子类可以拥有自己的属性和方法，即子类可以对父类进行扩展。
3. 子类可以用自己的方式实现父类的方法。

###多态

所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。

在Java中有两种形式可以实现多态：继承（多个子类对同一方法的重写）和接口（实现接口并覆盖接口中同一方法）。

##12.String StringBuffer和StringBuilder的区别是什么？String为什么是不可变的？

###可变性
简单的来说：String类中使用final关键字修饰字符数组来保存字符串，`private final char value[]`，所以String对象是不可变的。而StringBuilder与StringBuffer都继承自AbstractStringBuilder类，在AbstractStringBuilder中也是使用字符数组保存字符串`char[]value`但是没有用final关键字修饰，所以这两种对象都是可变的。

StringBuilder与StringBuffer的构造方法都是调用父类构造方法也就是AbstractStringBuilder实现的，大家可以自行查阅源码。

AbstractStringBuilder.java

	abstract class AbstractStringBuilder implements Appendable, CharSequence {
    	char[] value;
    	int count;
    	AbstractStringBuilder() {
   		}
    	AbstractStringBuilder(int capacity) {
        	value = new char[capacity];
    	}

###线程安全性

String中的对象是不可变的，也就可以理解为常量，线程安全。AbstractStringBuilder是StringBuilder与StringBuffer的公共父类，定义了一些字符串的基本操作，如expandCapacity、append、insert、indexOf等公共方法。StringBuffer对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder并没有对方法进行加同步锁，所以是非线程安全的。

###性能

每次对String类型进行改变的时候，都会生成一个新的String对象，然后将指针指向新的String对象。StringBuffer每次都会对StringBuffer对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用StringBuilder相比使用StringBuffer仅能获得10%~15%左右的性能提升，但却要冒多线程不安全的风险。

###对于三者使用的总结：

1. 操作少量的数据：适用String
2. 单线程操作字符串缓冲区下操作大量数据：适用StringBuilder
3. 多线程操作字符串缓冲区下操作大量数据：适用StringBuffer

##13.自动装箱与拆箱
 - 装箱：将基本类型用它们对应的引用类型包装起来；
 - 拆箱：将包装类型转换为基本数据类型；

##14.在一个静态方法内调用一个非静态成员为什么是非法的？
由于静态方法可以不通过对象进行调用，因此在静态方法里，不能调用其他非静态变量，也不可以访问非静态变量成员 。

##15.在Java中定义一个不做事且没有参数的构造方法的作用
Java程序在执行子类的构造方法之前，如果没有用`super（）`来调用父类特定的构造方法，则会调用父类中“没有参数的构造方法”。因此，如果父类中只定义了有参数的构造方法，而在子类的构造方法中又没有用`super（）`来调用父类中特定的构造方法，则编译时将发生错误，因为Java程序在父类中找不到没有参数的构造方法可供执行。解决办法是在父类里加上一个不做事且没有参数的构造方法。

##16.import java 和javax有什么区别？
刚开始的时候JavaAPI所必需的包是java开头的包，javax当时只是扩展API包来使用。然而随着时间的推移，javax逐渐地扩展成为Java API的组成部分。但是，将扩展从javax包移动到java包确实太麻烦了，最终会破坏一堆现有的代码。因此,最终决定javax包将成为标准API的一部分。

所以，实际上java和javax没有区别。这都是一个名字。

##17.接口和抽象类的区别是什么？
1. 接口的方法默认是public，所有方法在接口中不能有实现（Java 8开始接口方法可以有默认实现），而抽象类可以有非抽象的方法。
2. 接口中除了static、final变量，不能有其他变量，而抽象类中则不一定。
3. 一个类可以实现多个接口，但只能实现一个抽象类。接口自己本身可以通过extends关键字扩展多个接口。
4. 接口方法默认修饰符是public，抽象方法可以有public、protected和default这些修饰符（抽象方法就是为了被重写所以不能使用private关键字修饰！）
5. 从设计层面来说，抽象是对类的抽象，是一种模板设计，而接口是对行为的抽象，是一种行为的规范。

备注：在JDK 8中，接口也可以定义静态方法，可以直接用接口名调用。如果同时实现两个接口，接口中定义了一样的默认方法，则必须重写，不然会报错。

##18.成员变量与局部变量的区别有哪些？
1. 从语法形式上看：成员变量是属于类的，而局部变量是在方法中定义的变量或是方法的参数；成员变量可以被public,private,static等修饰符所修饰，而局部变量不能被访问控制修饰符及static所修饰；但是，成员变量和局部变量都能被final所修饰。
2. 从变量在内存中的存储方式来看：如果成员变量是使用`static`修饰的，那么这个成员变量是属于类的，如果没有使用`static`修饰，这个成员变量是属于实例的。而对象存在于堆内存，局部变量则存在于栈内存。
3. 从变量在内存中的生存时间上看：成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动消失。
4. 成员变量如果没有被赋初值：则会自动以类型的默认值而赋值（一种情况例外：被final修饰的成员变量也必须显示地赋值），而局部变量则不会自动赋值。

##19.创建一个对象用什么运算符？对象实体与对象引用有何不同？
new运算符，new创建对象实例（对象实例在堆内存中），对象引用指向对象实例（对象引用存放在栈内存中）。一个对象引用可以指向0个或1个对象（一根绳子可以不系气球，也可以系一个气球）；一个对象可以有n个引用指向它（可以用n条绳子系住一个气球）。

##20.什么是方法的返回值？返回值在类的方法里的作用是什么？
方法的返回值是指我们获取到的某个方法体中的代码执行后产生的结果！（前提是该方法可能产生结果）。返回值的作用：接收出结果，使得它可以用于其他的操作！

##21.一个类的构造方法的作用是什么？若一个类没有声明构造方法，该程序能正确执行吗？为什么？
主要作用是完成对类对象的初始化工作。可以执行。因为一个类即使没有声明构造方法也会有默认的不带参数的构造方法。

##22.构造方法有哪些特性？
1. 名字与类名相同。
2. 没有返回值，但不能用void声明构造函数。
3. 生成类的对象时自动执行，无需调用。

##23.静态方法和实例方法有何不同
1. 在外部调用静态方法时，可以使用“类名.方法名”的方式，也可以使用“对象名.方法名”的方式。而实例方法只有后面这种方式。也就是说，调用静态方法可以无需创建对象。
2. 静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），而不允许访问实例成员变量和实例方法；实例方法则无此限制。

##24.对象的相等与指向他们的引用相等，两者有什么不同？
对象的相等，比的是内存中存放的内容是否相等。而引用相等，比较的是他们指向的内存地址是否相等。

##25.在调用子类构造方法之前会先调用父类没有参数的构造方法，其目的是？
帮助子类做初始化工作。

##26.==与equals（重要）
==：它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象（基本数据类型==比较的是值，引用数据类型==比较的是内存地址）。

equals（）：它的作用也是判断两个对象是否相等。但它一般有两种使用情况：

 - 情况1：类没有覆盖equals（）方法。则通过equals（）比较该类的两个对象时，等价于通过"=="比较这两个对象。
 - 情况2：类覆盖了equals（）方法。一般，我们都覆盖equals（）方法来比较两个对象的内容是否相等；若它们的内容相等，则返回true（即认为这两个对象相等）。

**举个例子：**

	public class test1 {
	    public static void main(String[] args) {
	        String a = new String("ab"); // a 为一个引用
	        String b = new String("ab"); // b为另一个引用,对象的内容一样
	        String aa = "ab"; // 放在常量池中
	        String bb = "ab"; // 从常量池中查找
	        if (aa == bb) // true
	            System.out.println("aa==bb");
	        if (a == b) // false，非同一对象
	            System.out.println("a==b");
	        if (a.equals(b)) // true
	            System.out.println("aEQb");
	        if (42 == 42.0) { // true
	            System.out.println("true");
	        }
	    }
	}

**说明：**
 
 - String中的equals方法是被重写过的，因为object的equals方法是比较的对象的内存地址，而String的equals方法比较的是对象的值。
 - 当创建String类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个String对象。

##27.hashCode与equals（重要）
面试官可能会问你：“你重写过hashcode和equals么，为什么重写equals时必须重写hashCode方法？”

###hashCode（）介绍

hsahCode（）的作用是获取哈希码，也称为散列码；它实际上是返回一个int整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode（）定义在JDK的Object.java中，这就意味着Java中的任何类都包含有hashCode（）函数。

###为什么要有hashCode

**我们先以“HashSet如何检查重复”为例子来说明为什么要有hashCode：**当你把对象加入HashSet时，HashSet会先计算对象的hashcode值来判断对象加入的位置，同时也会与其他已经加入的对象的hashcode值作比较，如果没有相符的hashcode，HashSet会假设对象没有重复出现。但是如果发现有相同hashcode值的对象，这时会调用equals（）方法来检查hashcode相等的对象是否真的相同。如果两者相同，HashSet就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。（摘自我的Java启蒙书《Head first java》第二版）这样我们就大大减少了equals的次数，相应就大大提高了执行速度。

通过这里我们可以看出：`hashCode（）`的作用就是**获取哈希码**，也称为散列码；它实际上是返回一个int整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。`hashCode（）`在散列表中才有用，在其他情况下没用。在散列表中`hashCode（）`的作用是获取对象的散列码，进而确定该对象在散列表中的位置。

###hashCode（）与equals（）的相关规定

1. 如果两个对象相等，则hashcode一定也是相等的
2. 两个对象相等，对两个对象分别调用equals方法都返回true
3. 两个对象有相同的hashcode值，它们也不一定是相等的
4. **因此，equals方法被覆盖过，则hashCode方法也必须被覆盖**
5. hashCode（）的默认行为是对堆上的对象产生独特值。如果没有重写hashCode（），则该class的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）

推荐阅读：[Java hashCode() 和 equals()的若干问题解答](https://www.cnblogs.com/skywang12345/p/3324958.html)

##28.为什么Java中只有值传递？
[为什么Java中只有值传递？](https://github.com/Snailclimb/JavaGuide/blob/master/docs/essential-content-for-interview/MostCommonJavaInterviewQuestions/%E7%AC%AC%E4%B8%80%E5%91%A8%EF%BC%882018-8-7%EF%BC%89.md)

##29.简述线程、程序、进程的基本概念。以及他们之间关系是什么？

**线程**与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享同一块内存空间和一组系统资源，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。

**程序**是含有指令和数据的文件，被存储在磁盘或其他的数据存储设备中，也就是说程序是静态的代码。

**进程**是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。简单来说，一个进程就是一个执行中的程序，它在计算机中一个指令接着一个指令地执行着，同时，每个进程还占有某些系统资源如CPU时间，内存空间，文件，输入输出设备的使用权等等。换句话说，当程序在执行时，将会被操作系统载入内存中。线程是进程划分成的更小的运行单元。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。从另一角度来说，进程属于操作系统的范畴，主要是同一段时间内，可以同时执行一个以上的程序，而线程则是在同一程序内几乎同时执行一个以上的程序段。

##30.线程有哪些基本状态？

Java线程在运行的生命周期中的指定时刻只可能处于下面6种不同状态的其中一个状态。
						
	状态名称		|             	说明
	NEW			|初始状态，线程被构建，但是还没有调用start（）方法
	RUNNABLE	|运行状态，Java线程将操作系统中的就绪和运行两种状态笼统地称作“运行中”	
	BLOCKED		|阻塞状态，表示线程阻塞于锁
	WAITING		|等待状态，表示线程进入等待状态，进入该状态表示当前线程需要等待其他线程做出一些特定动作（通知或中断）
	TIME_WAITING|超时等待状态，该状态不同于WAITING，它是可以在指定的时间自行返回的
	TERMINATED	|终止状态，表示当前线程已经执行完毕

线程在生命周期中并不是固定处于某一个状态而是随着代码的执行在不同状态之间切换。Java线程状态变迁如下图所示：![](http://camo.githubusercontent.com/88ca089de34d29350d6b72ee1b9e9c8f8f8691f2/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31392d312d32392f4a6176612532302545372542412542462545372541382538422545372538412542362545362538302538312545352538462539382545382542462538312e706e67)

由上图可以看出：

线程创建之后它将处于**NEW（新建）**状态，调用`start（）`方法后开始执行，线程这时候处于**READY（可运行）** 状态。可运行状态的线程获得了cpu时间片（timeslice）后就处于**RUNNING（运行）**状态。
>操作系统隐藏Java虚拟机（JVM）中的READY和RUNNING状态，它只能看到RUNNABLE状态，所以Java系统一般将这两个状态统称为**RUNNABLE（运行中）**状态。
>![](https://camo.githubusercontent.com/916fefa029894b21921d3085f513b9a7f08ebad2/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d332f52554e4e41424c452d56532d52554e4e494e472e706e67)

当线程执行`wait（）`方法之后，线程进入**WAITING（等待）**状态。进入等待状态的线程需要依靠其他线程的通知才能够返回到运行状态，而**TIME_WAITING（超时等待）**状态相当于在等待状态的基础上增加了超时限制，比如通过`sleep（long millis）`方法或`wait（long millis)`方法可以将Java线程置于TIMED WAITING状态。当超时时间到达后Java线程将会返回到RUNNABLE状态。当线程调用同步方法时，在没有获取到锁的情况下，线程将会进入到 **BLOCKED（阻塞）**状态。线程在执行Runnable的`run（）`方法之后将会进入到**TERMINATED（终止）**状态。
